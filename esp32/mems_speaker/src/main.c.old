#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/stat.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/adc.h"
#include "driver/i2s.h"
#include "esp_err.h"
#include "hal/i2s_types.h"

#define BCLK_PIN 32
#define LRC_PIN 25
#define SPK_DIN_PIN 22
#define MIC_SD_PIN 33

#define BUFF_SIZE 1024

static const int i2s_num = I2S_NUM_0;
static int16_t read_buff[BUFF_SIZE];
static uint8_t write_buff[BUFF_SIZE];

static short signal_mem[1];
static const float alpha = 0.97;

static esp_err_t init_i2s(){
    esp_err_t err;

    i2s_config_t i2s_config = {
        .mode = I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_RX,
        .sample_rate = 16000,
        .bits_per_sample = 16,
        .communication_format = I2S_COMM_FORMAT_STAND_I2S,
        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
        .intr_alloc_flags = 0,
        .dma_buf_count = 8,
        .dma_buf_len = BUFF_SIZE,
        .use_apll = true,
    };

    err = i2s_driver_install(i2s_num, &i2s_config, 0, NULL);
    if(err != ESP_OK){
        return err;
    }

    i2s_pin_config_t pin_config = {
        .bck_io_num = BCLK_PIN,
        .ws_io_num = LRC_PIN,
        .data_out_num = SPK_DIN_PIN,
        .data_in_num = MIC_SD_PIN,
    };
    err = i2s_set_pin(i2s_num, &pin_config);
    if(err != ESP_OK){
        return err;
    }

    return i2s_zero_dma_buffer(i2s_num);
}

u_int16_t preemphasis(uint16_t x){
    float x_em = 0;
    x_em = (short) x - alpha * signal_mem[0];
    signal_mem[0] = (short) x;
    return (uint16_t) x_em;
}

void app_main() {
    esp_err_t ret;
    const TickType_t xDelay = 1000 / portTICK_PERIOD_MS;//0.0625 * BUFF_SIZE / portTICK_PERIOD_MS; // 16000 sample rates
    
    ret = init_i2s();
    if(ret != ESP_OK){
        printf("err: %s", esp_err_to_name(ret));
        return;
    }

    // ret = init_i2s_mic();
    // if(ret != ESP_OK){
    //     printf("err: %s", esp_err_to_name(ret));
    //     return;
    // }
    
    signal_mem[0] = 0;
    int count = 0;
    size_t bytes_writen;
    size_t bytes_read;
    while(1){
        // vTaskDelay(xDelay);

        ret = i2s_read(i2s_num, read_buff, sizeof(read_buff), &bytes_read, portMAX_DELAY);
        if(ret != ESP_OK){
            printf("err: %s", esp_err_to_name(ret));
            break;
        }

        // int16_t num_samples = bytes_read / 8;
        // printf("Read %d bytes\n", bytes_read);
        // for(int i = 0; i < BUFF_SIZE; i++){
        //     // int16_t pre = (int16_t) *(read_buff+i);
        //     // int16_t post = (int16_t) *(read_buff+i+1);
        //     // int16_t sample = pre << 8 | post;
        //     printf("sample value: %d ", read_buff[i]);
        // }
        ret = i2s_write(i2s_num, read_buff, sizeof(read_buff), &bytes_writen, portMAX_DELAY);
        if(ret != ESP_OK){
            printf("err: %s", esp_err_to_name(ret));
            break;
        }
        // break;

    //     // Pre-emphasis
    //     uint16_t signal = 0;
    //     signal = signal << 2; // Amplify 4 times

    //     memcpy(buff + count, &signal, 2);
    //     count += 2;

    //     if(count == 128){
    //         count = 0;
    //         ret = i2s_write(i2s_num, (const void *)buff, sizeof(buff), &bytes_writen, portMAX_DELAY);
    //         if(ret != ESP_OK){
    //             printf("err: %s", esp_err_to_name(ret));
    //             break;
    //         }
    //     }
    // }
    }

    i2s_driver_uninstall(i2s_num);
}